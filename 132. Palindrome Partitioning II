package com.zjx.leetcode7;

public class Num132 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        int res = solution.minCut("ababbbabbaba");
        System.out.println(res);
    }
}
class Solution {
    // 主函数
    public int minCut(String s) {
        //longest是最长的回文字符
        String longest = longestPalindrome(s);
        System.out.println("longest初始=" + longest);
        if (longest.length() == s.length()) return 0;
        if (longest.length() + 1 == s.length()) return 1;
        StringBuilder stringBuilder = new StringBuilder();
        int i = 0;
        int j = 0;
        int count = 0;
        while (longest.length() != 0){
            for (i = 0; i < s.length() && j < longest.length(); i++) {
                if (s.charAt(i) == longest.charAt(j)){
                    j++;
                }
                else {
                    stringBuilder.append(s.charAt(i));
                }
            }
            while (i < s.length()){
                stringBuilder.append(s.charAt(i));
                ++i;
            }//for之后，stringBuilder里面存的是剩下的字符串
            System.out.println("剩下的字符串=" + stringBuilder.toString());
            count++;
            longest = longestPalindrome(stringBuilder.toString());
            System.out.println("longet运行中=" + longest);
            j = 0;
            s = stringBuilder.toString();
            stringBuilder = new StringBuilder();
        }

        return count - 1;
    }

    // 辅助函数：寻找回文串
    private String palindrome(String s, int left, int right) {
        // 在区间 [0, s.length() - 1] 中寻找回文串，防止下标越界
        char[] c =  s.toCharArray();
        while (left >=0 && right < s.length()) {
            // 是回文串时，继续向两边扩散
            if (c[left] == c[right]) {
                left--;
                right++;
            } else {
                break;
            }
        }

        // 循环结束时的条件是 s.charAt(left) != s.charAt(right), 所以正确的区间为 [left + 1, right), 方法 substring(start, end) 区间是 [start, end), 不包含 end
        return s.substring(left + 1, right);
    }
    //辅助函数：寻找最长的回文串
    private String longestPalindrome(String s){
        // 记录最长回文串
        String longest = "";
        char[] sChar = s.toCharArray();
        // 穷举以所有点（奇数一个点，偶数两个点）为中心的回文串
        for (int i = 0; i < sChar.length; i++) {
            // 当回文串是奇数时，由一个中心点向两边扩散
            String s1 = palindrome(s, i, i);
            // 当回文串是偶数时，由中间的两个中心点向两边扩散
            String s2 = palindrome(s, i, i + 1);

            // 三元运算符：判断为真时取冒号前面的值，为假时取冒号后面的值
            longest = longest.length() > s1.length() ? longest : s1;
            longest = longest.length() > s2.length() ? longest : s2;
        }
        return longest;
    }
}
